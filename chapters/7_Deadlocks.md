# بن بست \label{ch:بن‌بست}در محیط‌های multi programming ممکنه چند پردازه سر منابع محدود سیستم با هم رقابت کنند. یه پردازه ممکنه درخواست دسترسی به یه منبع رو بده که دست کس دیگه‌ایه در این حالت پردازه منتظر می‌مونه تا اون پردازه‌ی دیگه کارشو تموم کنه(به این عمل wait میگیم و همه سیستم عامل‌ها اون رو پشتیبانی نمی‌کنن). گاهی وقتا پیش میاد که این پردازه هیچ وقت نمی‌تونه کارشو تموم کنه(توی وضعیت wait باقی می‌مونه) چرا که منبعی که درخواست کرده دست یه پردازه دیگه‌ایه که اونم در وضعیت wait قرار داره . به این حالت deadloock می‌گیم. اگه گیج شدید ایرادی نداره، چون توی این فصل مفصل به این موضوع می‌پردازیم. مثاله که کتاب زده مزخرف‌ترین مثال ممکنه. اما یه مثال بهتر می‌تونیم داشته باشیم. فرض کنید این قانون رو داریم که هر ماشینی که به یه چهارراه می‌رسه اول باید توقف کنه و بعد به مسیری که می‌خواد بره. حالا فرض کنید ماشین‌های زیر می‌خوان که از چهارراه رد بشن(خیابون‌های این چهارراه ظرفیت یک ماشین رو دارند). ((((اسم ماشنی‌ها)))) ماشین xxx می‌خواد به خیابونی بره که ماشین xxx قرار داره و ماشین xxx هم می‌خواد به خیابونی بره که ماشین xxx توش هست. در این حالت این ماشین‌ها برای  همیشه توی این  چهارراه متوقف می‌شن. اگه این حالت توی دنیای سیستم عامل برای دو تا پردازه اتفاق بیفته به این حالت   بن‌بست می‌گیم.در این فصل ما روش‌هایی رو معرفی می‌کنیم که سیستم عامل‌ها می‌توانند به کار گیرند تا از بن‌بست جلوگیری کنند یا حتی باهاش مقابله کنند. برنامه‌هایی هستند که می‌تونن بن‌بست رو شناسایی کنند ولی معمولا سیستم عامل‌ها روشی برای جلوگیری از بن‌بست رو پیاده سازی نمی‌کنند و این‌که برنامه‌ای بنویسیم که دچار بن‌بست نشه رو به برنامه‌نویسی واگذار می‌کنند. سیستم عامل‌هایی که برای کارهای معمولی استفاده می‌شن معمولاً به ندرت دچار بن‌بست می‌شوند. چرا که پردازه‌های کاملا متفاوتی در حال اجرا هستند.(وقتی که دارید ماشین بازی می‌کنید و آهنگ گوش می‌دید درحالی که اون‌ور download manager داره یه چیزی  دانلود می‌کنه چه بن‌بستی ممکنه رخ بده؟) در این فصل می‌خواهیم:((((این‌جا اینا نقطه اولشون باشه))))  بن‌بست رو توضیح بدیم که باعث می‌شه پردازه‌های هم‌گام نتونن کارشون رو تموم کنند.    یه سری روش رو ببینیم که با اون‌ها از بن‌بست جلوگیری کنیم یا باهاش مقابله کینم.## شبیه‌سازی سیستمسیستم‌های کامپیوتری منابع محدودی دارند که بین پردازه‌هایی که روی آن منابع رقابت می‌کنند پخش شده است. منابع به انواع و کلاس‌های متفاوتی تقسیم می‌شوند، که هر کلاس دارای تعداد محدودی نمونه است. cpu cycle, printer, I/O device, file و ...  نمونه‌هایی از این کلاس‌ها هستند. مثلا اگر سیستم دو پردازنده داشته باشد کلاس CPU داری دو نمونه است.  توجه به این نکته ضروری است که از نظر پردازه باید نمونه‌هایی که در یک کلاس قرار می‌گیرند یکسان باشند. ( مثلا برای  استادی که اتاقش توی طبقه هفتم ساختمون جدیده پرینتر طبقه هفتم با پرینتر سایت یکی محسوب نمی‌شه)[^sample-footnote] پس باید  هر  نمونه‌ای در  کلاس کاری که پردازه خواهان انجام اونه بتونه انجام بده و برای پردازه فرق نکنه که کدوم نمونه کارشو انجام می‌ده (الان   این دو تا پرینتر باید توی کلاس‌های مجزایی قرار بگیرند)  در فصل پنجم در مورد ابزارهای هم‌گام سازی مثل mutex lockes و semaphores حرف زدیم. این‌ها منشأ اصلی بن‌بست هستند. از این قفل‌ها استفاده می‌کنیم تا از ساختمان داده‌های حساس سیستم (صف‌ها، لیست‌های پیوندی و ... ) محافظت کینم. پس هر یک از این قفل‌ها هم دریک کلاس منابع قرار می‌گیرد.بدیهیست که یه پردازه باید قبل از دسترسی به یک منبع درخواست مجوز استفاده از اون منبع را به سیستم بده و وقتی کارش با اون منبع تموم شد باید اون رو آزاد کنه. چیز بدیهی دیگه اینه که پردازه می‌تونه بدون محدودیت هر تعدادی و از هر کلاسی از منابع سیستم رو هر وقت خواست درخواست کنه تا بتونه کاری که براش طراحی شده انجام بده. (طبیعیه که یه پردازه نمی‌تونه بیشتر از تعداد نمونه‌ّهای یک کلاس رو از سیستم درخواست کنه، مثلا چهار تا پرینتر بخواد در حالی که سه تا پرینتر داریم)در سیستم‌های عادی پردازه برای استفاده از سیستم باید سلسله مراتب زیر را رعایت کند (((( این‌جا نقطه قرار بگیره))))\coloredtext{blue}{درخواست:}پردازه باید قبل از دسترسی به منبع درخواستی  به سیستم بدهد. طبیعیه که اگه منبع در حال حاضر در دسترس نباشه (منبع در اختیار یه پردازه دیگه باشه) درخواست پردازه تعلیق می‌شه تا زمانی که پتونیم منبع رو در اختیارش بزاریم.\coloredtext{blue}{مصرف:}در این مرحله پردازه می‌تواند روی منبع کاری را که می‌خواهد انجام دهد.\coloredtext{blue}{رها کردن:}پردازه منبع را رها می‌کند.گرفتن و رها کردن منبع می‌تواند فراخوان سیستمی باشد نظیر request() , respond()  برای deviceها، open() , close() برای فایل و allocate() , free() برای حافظه. همچنین همانطور که در فصل ۵ (((( لینک به فصل پنجم)))) دیدیم درخواست و رها کردن semaphore هم توسط توابع wait() , signal() انجام می‌شود و نیز دیدیم که برای  mutex lockها هم از  release() , acquire()استفاده می‌کنیم. برای استفاده از هر منبعی که هسته آن را مدیریت می‌کند هر درخواستی که توسط پردازه یا ریسمان[^thread] انجام می‌دهد سیستم عامل چک می‌کند که آیا منبع را به پردازه (یا ریسمان) داده‌ایم یا نه؟ system table جزئیات این|که منبع گرفته شده یا آزاد است و اگر گرفته شده است چه پردازه‌ای آن را در اختیار دارد را نگهداری می‌کند. اگر پردازه درخواست دسترسی به منبعی را بدهد که گرفته شده است می‌تواند به صف انتظار این منبع منتقل شود.مجموعه‌ای از پردازه‌ها دچار پن‌بست شده‌اند وقتی که هر پردازه‌ای منتظر اتفاقی[^event]باشد که تنها می‌تواند توسط پردازه‌ی دیگری درون آن مجموعه اتفاق بیفتد.اتفاقی که ما منتظر وقوع اونیم گرفتن و رها کردن منبع است. منابع می‌تونن منطقی مثل فایل، semaphor و ... یا فیزیکی مانند چاپ‌گر، حافظه، CPU cycle و ... باشند. البته منابع دیگری مانند IPC[^IPC]هم هستند که می‌توانند باعث بن‌بست شوند.برای این که وضعیت بن‌بست خوب براتون جا بیفته یه مثال می‌زنم. یه سیستم رو در نظر بگیرید که سه دستگاه CD drive رو در نظر بگیرید. سه پردازه در این سیستم در حال اجراست که هر کدام یکی از این CD drive ها را در اختیار دارد. اگر هر سه پردازه یک دستگاه CD drive دیگر درخواست کنند. هر سه پردازه در وضعیت بن‌بست قرار می‌گیرند، چرا که هر کدام منتظر اتفاقی [^event]هستند که تنها می‌تواند توسط یکی دیگر از پردازه‌های درون مجموعه اتفاق بیفتد. در این مثال نوع منابع یکسان بود اما لزومی ندارد همیشه این‌گونه باشد. برای مثال سیستمی با یک دستگاه DVD drive و یک دستگاه چاپ‌گر را در نظر بگیرید. پردازه pi ((( ( اینو ‌index کن)))) دستگاه DVD drive و پردازه pj ((((اینو index کن)))) چاپگر را در اختیار دارد. اگر pi چاپگر را و  پردازه pj دستگاه DVD drive را درخواست کند  آن‌گاه پن‌بست اتفاق می‌افتد. هنگامی که یک برنامه‌ی multithred رو مدیریت می‌کنید برنامه باید بتواند وقوع بن‌بست رو بفهمه و اقدامات لازم رو براش انجام بده. ابزارهای قفل کردن که در فصل پنجم ((((لینک به فصل پنجم)))) باهاشون آشنا شدید برای این‌که از وقوع رقابت بین پردازه‌ها جلوگیری بشه ساخته شدند. هنگام استفاده از این ابزارها حتما باید به این‌که تخصیص منابع و رها شدن آن‌ها چگونه‌اند دقت کنید و گرنه باید در انتظار بن‌بست باشید.## خصوصیاتone day I gone a fly away ...## روش‌هایی برای رسیدگی به بن‌بستone day I gone a fly away ...## جلوگیری از بن‌بستone day I gone a fly away ...## پرهیز از بن‌بستone day I gone a fly away ...## تشخیص بن‌بستone day I gone a fly away ...## بازیابی بن‌بستone day I gone a fly away ...## خلاصهone day I gone a fly away ...[^sample-footnote]: این مثال رو از دانشکده مهندسی برق و کامپیوتر گرفتم برای دیگر عزیزان که با این دانشکده آشنایی ندارند مثال دیگری می‌زنم. برای استادی که در طبقه هفتم است پرینتری که در همان طبقه قرار دارد با پرینتری که در ساختمان دیگریست مسلما تفاوت می‌کند و این دو دستگاه نباید در یک کلاس قرار گیرند.[^thread]: thread[^event]: event[^IPC]: (((توضیح در مورد IPC)))